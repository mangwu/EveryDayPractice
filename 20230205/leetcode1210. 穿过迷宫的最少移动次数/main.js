/*
 * @Author: mangwu                                                             *
 * @File: main.js                                                              *
 * @Date: 2023-02-05 12:44:10                                                  *
 * @LastModifiedDate: 2023-02-05 15:22:27                                      *
 * @ModifiedBy: mangwu                                                         *
 * -----------------------                                                     *
 * Copyright (c) 2023 mangwu                                                   *
 * -----------------------                                                     *
 * @HISTORY:                                                                   *
 * Date   	            By 	    Comments                                       *
 * ---------------------	--------	----------------------------------------------- *
 */

// 你还记得那条风靡全球的贪吃蛇吗？

// 我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。

// 每次移动，蛇可以这样走：

// 如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。
// 如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。
// 如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。

// 如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。

// 返回蛇抵达目的地所需的最少移动次数。

// 如果无法到达目的地，请返回 -1。
const DIRS = [
  [0, 1],
  [1, 0],
];
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumMoves = function (grid) {
  const set = new Set();
  let queue = [
    [
      [0, 0],
      [0, 1],
    ],
  ];
  const n = grid.length;
  set.add(1);
  let cur = 0;
  while (queue.length) {
    const nxt = [];
    for (const q of queue) {
      if (
        q[0][0] === n - 1 &&
        q[0][1] === n - 2 &&
        q[1][0] === n - 1 &&
        q[1][0] === n - 1
      ) {
        return cur;
      }
      if (q[0][0] === 8 && q[0][1] === 11) {
        console.log("---");
      }
      for (const dir of DIRS) {
        // 平移
        const i = [q[0][0] + dir[0], q[0][1] + dir[1]];
        const j = [q[1][0] + dir[0], q[1][1] + dir[1]];
        let sum = i[0] * n + i[1] + j[0] * n + j[1];
        console.log(sum);
        if (
          !set.has(sum) &&
          i[0] >= 0 &&
          i[0] < n &&
          i[1] < n &&
          i[1] >= 0 &&
          j[0] >= 0 &&
          j[0] < n &&
          j[1] < n &&
          j[1] >= 0 &&
          grid[i[0]][i[1]] === 0 &&
          grid[j[0]][j[1]] === 0
        ) {
          set.add(sum);
          nxt.push([i, j]);
        }
      }
      // 旋转
      if (q[1][1] - q[0][1] === 1) {
        // 水平，顺时针旋转
        const i = [q[0][0] + 1, q[0][1] + 0];
        const j = [q[1][0] + 1, q[1][1] + 0];
        let sum = q[0][0] * n + q[0][1] + i[0] * n + i[1];
        console.log(sum);

        if (
          !set.has(sum) &&
          i[0] >= 0 &&
          i[0] < n &&
          i[1] < n &&
          i[1] >= 0 &&
          j[0] >= 0 &&
          j[0] < n &&
          j[1] < n &&
          j[1] >= 0 &&
          grid[i[0]][i[1]] === 0 &&
          grid[j[0]][j[1]] === 0
        ) {
          set.add(sum);
          nxt.push([q[0], i]);
        }
      } else {
        // 垂直，逆时针旋转
        const i = [q[0][0] + 0, q[0][1] + 1];
        const j = [q[1][0] + 0, q[1][1] + 1];

        let sum = q[0][0] * n + q[0][1] + i[0] * n + i[1];
        console.log(sum);

        if (
          !set.has(sum) &&
          i[0] >= 0 &&
          i[0] < n &&
          i[1] < n &&
          i[1] >= 0 &&
          j[0] >= 0 &&
          j[0] < n &&
          j[1] < n &&
          j[1] >= 0 &&
          grid[i[0]][i[1]] === 0 &&
          grid[j[0]][j[1]] === 0
        ) {
          set.add(sum);

          nxt.push([q[0], i]);
        }
      }
    }
    cur++;
    queue = nxt;
    console.log(nxt);
  }
  return -1;
};

// 0  1  2  3  4  5
// 6  7  8  9  10 11
// 12 13 14 15 16 17

console.log(
  minimumMoves([
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
    [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0],
    [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
  ])
);

// [8,8] [9,8]
// [8,9] [9,9]
