/*
 * @Author: mangwu                                                             *
 * @File: main.js                                                              *
 * @Date: 2022-08-24 10:57:46                                                  *
 * @LastModifiedDate: 2022-08-24 11:12:38                                      *
 * @ModifiedBy: mangwu                                                         *
 * -----------------------                                                     *
 * Copyright (c) 2022 mangwu                                                   *
 * -----------------------                                                     *
 * @HISTORY:                                                                   *
 * Date   	            By 	    Comments                                       *
 * ---------------------	--------	----------------------------------------------- *
 */

// 给你一个二进制字符串 s 。在一秒之中，所有 子字符串 "01" 同时 被替换成 "10" 。
// 这个过程持续进行到没有 "01" 存在。

// 请你返回完成这个过程所需要的秒数。

/**
 * @param {string} s
 * @return {number}
 */
var secondsToRemoveOccurrences = function (s) {
  // 1到前面，至少需要的秒数是前面0的个数
  // 而真实情况是0011, 可以看到最后一个1需要等待前面的1先移位后才能移动
  // 所以需要考虑的是如果前面是1，当前1移到前面需要的秒数是：前面1移到前面的时间加上1(等待时间)
  // 同理00111 ，对于最后一个1，需要的秒送仍然是前面1移到前面的时间加上1，实际上最后一个1等待2秒，但是其中1秒被前面一个1计算了，所以不必重复计算
  // 或者可以这样理解：我们得到了前面1到达的秒送，但是因为它在前， 只有等它移动后才能启动，所以需要等一秒
  // 这样就可以使用动态规划求救，最后一个1到达的时间一定是最长的，因为它前面的0和1最多，且要等的时间最长
  // 如果遇到0，则可以将时间加1，因为后面的都要跨越这个0， 如果遇到1，就是计算前面0的个数和pre+1的大值
  let f = 0,
    pre0 = 0;
  for (const ch of s) {
    if (ch == "0") {
      pre0++;
    } else if (pre0) {
      // 前面一定有0才能移位
      f = Math.max(f + 1, pre0);
    }
  }
  return f;
};
