/*
 * @Author: mangwu                                                             *
 * @File: main.js                                                              *
 * @Date: 2023-01-09 09:44:43                                                  *
 * @LastModifiedDate: 2023-01-09 11:15:37                                      *
 * @ModifiedBy: mangwu                                                         *
 * -----------------------                                                     *
 * Copyright (c) 2023 mangwu                                                   *
 * -----------------------                                                     *
 * @HISTORY:                                                                   *
 * Date   	            By 	    Comments                                       *
 * ---------------------	--------	----------------------------------------------- *
 */

// 给你一个下标从 0 开始的整数数组 nums 。

// 三个下标 i ，j 和 k 的 有效值 定义为 ((nums[i] | nums[j]) & nums[k]) 。

// 一个数组的 xor 美丽值 是数组中所有满足 0 <= i, j, k < n  的三元组 (i, j, k) 的 有效值 的异或结果。

// 请你返回 nums 的 xor 美丽值。

// 注意：

// val1 | val2 是 val1 和 val2 的按位或。
// val1 & val2 是 val1 和 val2 的按位与。

/**
 * @param {number[]} nums
 * @return {number}
 */
var xorBeauty = function (nums) {
  // 每个比特互不相干
  // 将其拆分成每个比特单独看
  // 问题转换成只有0和1看怎么算
  // 异或0没有关系，看有多少个1
  // ((a|b) &c) = 1
  // c = 1 , a或b至少有一个1
  // 遍历nums，可以获得每个数每一位的1和0，计算出每一位1的个数
  // 假设1的个数为y，那么就有n-y个0的个数（n为数组长度）
  // ((a|b) &c)的最终1的结果就有 ones = y * (n^2 - x^2)  // c为1，有y种结果，a|b等于1，等价于所有a和b的情况减去a|b是0的情况
  // 就看ones的奇偶性即可，奇数个1异或就是1，偶数个1异或就是0
  // 继续将ones化简
  // ones = (n^2 - (n-y)^2)*y
  //      = (n^2 - n^2 + 2ny - y^2)*y
  //      = (2n-y)*y^2
  // 2n是偶数，所以要求y^3的奇偶性，即y的奇偶性
  // 看y的奇偶性就行
  // 由于y是1的个数，也可以看出是这个比特位的0和1异或的结果
  // 1的个数的奇偶性和这些比特位异或起来的结果完全一样，比特位的结果就是bit位数字的异或
  // 转换成每个num的异或
  return nums.reduce((pre, cur) => cur ^ pre);
};

// 变形题，把异或改成求值=》把1求出来后求值

// 对称性
// (a | b) & c

// a的索引为i，b的索引为j
// 根据对称性，肯定也能取到(j, i)的情况
// 即(a | b)和(b | a)成对出现，那么它们的异或肯定是0
// 即只有i == j的情况下才对答案有贡献，所以a | b就是nums[i]
// 再看 nums[i] & c
// 同理，c的索引是k，那么也能取到(k ,i)的情况
// 即(nums[i] & c) 和(c & nums[i])成对出现，那么它们的异或肯定是0
// 即只有i == k 的情况下才对答案有贡献
// 所以就是计算 nums[i]为1的个数，再对其求异或
// 每个bit位的异或就是1的个数的异或，  因为每个比特互不相干，所以整体就是每个数的异或

