// 给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：

// 0 表示这个格子是空的，所以你可以穿过它。
// 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
// -1 表示这个格子里有荆棘，挡着你的路。
// 请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：

// 从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 0 或者 1 的格子）；
// 当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
// 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）；
// 如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。

/**
 * @param {number[][]} grid
 * @return {number}
 */
var cherryPickup = function (grid) {
  const n = grid.length;
  // 需要考虑从(n-1, n-1)返回到(0,0)时，所能获取到的最多樱桃
  // 可以等价于从(0,0)到(n-1,n-1)走了两次，这两次就相当于两个人从(0,0)开始走到(n-1,n-1)
  // 如果使用动态规划，需要计算的就是两个人同时从(0,0)出发，到达(n-1,n-1)的能获取到的最大樱桃数之和
  // 两人分别到达(x1,y1)和(x2,y2)，因为是同时出发，所以x1+y1 === x2+y2 === k <= 2n - 2
  // 当x1 === x2时，y1 === y2，两个人必然到达了相同的格子，这个时候就只能获取到1个樱桃
  // 定义f[k][x1][x2]是两个人分别从(0,0)开始到达(x1, k-x1)、(x2,k-x2)能获取到的最大樱桃数之和
  // 因为k，x1，x2确定后，两个人的位置是确定的，故而可以揽括不同时刻，任意位置，两个人能获得的最大樱桃的所有情况

  const dp = new Array(2 * n - 1)
    .fill(0)
    .map((v) => new Array(n).fill(0).map((v) => new Array(n).fill(-Infinity))); // 默认不可到达
  dp[0][0][0] = grid[0][0]; // 初始情况(0,0)
  for (let k = 1; k < n * 2 - 1; k++) {
    // 在第k步时，遍历两人能到达的x1和x2
    for (let x1 = Math.max(0, k - n + 1); x1 <= Math.min(k, n - 1); x1++) {
      const y1 = k - x1;
      // 遇到荆棘
      if (grid[x1][y1] === -1) continue;
      for (let x2 = x1; x2 <= Math.min(k, n - 1); x2++) {
        // 没必要计算x2小于x1的情况，因为这种时候相当于将两个人位置对调了
        const y2 = k - x2;
        if (grid[x2][y2] === -1) continue;
        // 转移情况
        let res = dp[k - 1][x1][x2]; // 两个人都是从上一个步往右走到当前位置的
        if (x1 > 0) {
          // x1往下，x2往右
          res = Math.max(res, dp[k - 1][x1 - 1][x2]);
        }
        if (x2 > 0) {
          // x1往右，x2往下
          res = Math.max(res, dp[k - 1][x1][x2 - 1]);
        }
        if (x1 > 0 && x2 > 0) {
          // x1和x2都往下
          res = Math.max(res, dp[k - 1][x1 - 1][x2 - 1]);
        }
        res += grid[x1][y1];
        if (x1 !== x2) {
          // 如果二者相等说明到了同一个位置，最多只能获取一个樱桃
          res += grid[x2][y2];
        }
        dp[k][x1][x2] = res;
      }
    }
  }
  return Math.max(dp[2 * n - 2][n - 1][n - 1], 0);
};

//
