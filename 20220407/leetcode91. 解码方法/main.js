/*
 * @Author: mangwu                                                             *
 * @File: main.js                                                              *
 * @Date: 2022-04-07 14:20:24                                                  *
 * @LastModifiedDate: 2022-04-07 17:13:20                                      *
 * @ModifiedBy: mangwu                                                         *
 * -----------------------                                                     *
 * Copyright (c) 2022 mangwu                                                   *
 * -----------------------                                                     *
 * @HISTORY:                                                                   *
 * Date   	            By 	    Comments                                       *
 * ---------------------	--------	----------------------------------------------- *
 */

// 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

// 'A' -> "1"
// 'B' -> "2"
// ...
// 'Z' -> "26"
// 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。
// 例如，"11106" 可以映射为：

// "AAJF" ，将消息分组为 (1 1 10 6)
// "KJF" ，将消息分组为 (11 10 6)
// 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

// 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

// 题目数据保证答案肯定是一个 32 位 的整数。

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {
  // 声明一个1 - 26的可信解码表
  const hash = new Set(new Array(26).fill(0).map((_v, i) => i + 1 + ""));
  // s中的字符可以选择一个或者2个组成一个解码
  // 从后向前遍历，
  // 当前字符所构成的解码方式是前面一个的作为单个时的解码方式
  // 和不作为单个时，再后面一个字符的合
  let len = s.length;
  if (len == 1) {
    if (hash.has(s)) {
      return 1;
    }
    return 0;
  }
  if (len == 2) {
    // 这里需要保证s不是10或者20
    if (s == "10" || s == "20") {
      return 1;
    }
    if (hash.has(s)) {
      return 2;
    }
    // 01 02 等情况
    if (s.includes("0")) {
      return 0;
    }
    return 1;
  }
  const dp = new Array(len + 1).fill(0).map((_v) => new Array(2).fill(0));
  // 第一个元素保存字符是单个时的方式，第二个元素表示和后面的元素组成一个的情况
  dp[len - 1][0] = 1;
  // 最后一位是0的情况，前面一位必须是1或者2
  if (s[len - 1] == "0") {
    if (s[len - 2] !== "1" && s[len - 2] !== "2") {
      return 0;
    }
    dp[len - 1][0] = 0;
  }
  for (let i = len - 2; i >= 0; i--) {
    // 不是0的情况
    if (hash.has(s[i])) {
      // 单个情况就是后面两个之后
      dp[i][0] = dp[i + 1][0] + dp[i + 1][1];
      // 非单个情况，且后面的元素必须
      if (hash.has(s.substring(i, i + 2)) && s[i + 2] !== "0") {
        // 可以组成两个的情况  后面两个的组合方式(如果为0,就新增一种方式，如果不为0，就是它们之和)
        dp[i][1] =
          dp[i + 2][0] + dp[i + 2][1] ? dp[i + 2][0] + dp[i + 2][1] : 1;
        // 不能组成两个，那么默认就是0
      }
    } else {
      // 0的前面必须是1或者2
      if (s[i - 1] == undefined || (s[i - 1] !== "1" && s[i - 1] !== "2")) {
        return 0;
      }
      // 0的前面是1或者2
      // 继承后面的情况
      dp[i][0] = dp[i + 1][0];
      dp[i][1] = dp[i + 1][1];
      dp[i - 1][0] = dp[i][0] + dp[i][1];
      dp[i - 1][1] = 0;
      i--;
    }
  }
  return dp[0][0] + dp[0][1];
};
numDecodings("2261221411587252144121364");
