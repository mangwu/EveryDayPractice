/*
 * @Author: mangwu                                                             *
 * @File: main.js                                                              *
 * @Date: 2022-02-22 08:33:36                                                  *
 * @LastModifiedDate: 2022-02-22 14:19:29                                      *
 * @ModifiedBy: mangwu                                                         *
 * -----------------------                                                     *
 * Copyright (c) 2022 mangwu                                                   *
 * -----------------------                                                     *
 * @HISTORY:                                                                   *
 * Date   	            By 	    Comments                                       *
 * ---------------------	--------	----------------------------------------------- *
 */

// 给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。

// 比方说，如果 nums = [1, 2, 3, 4] ：
// [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。
// [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。
// 请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。

// nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。
// 如果两个子集删除的下标不同，那么它们被视为不同的子集。

//1 <= nums[i] <= 30
const mod = Math.pow(10, 9) + 7;
/**
 * @param {number[]} nums
 * @return {number}
 */
var numberOfGoodSubsets = function (nums) {
  // nums 中的数无论如何选择相乘，都是nums中所有数相乘的约数
  // nums选择的数必然能够由不同的质数相乘得到
  // nums[i]的范围确定: 1 - 30 那么可选的nums[i]为1 2 3 5 6 7 10 11 13 14 15 17 19 21 22 23 26 29 30
  // 那么从中选任意个质约数不重叠的即可
  // 所有的质约数有 2 3 5 7 11 13 17 19 23 29
  // 有1 相等于子集个数乘以2^(1的个数),因为1不做重复处理,可以同时存在
  // 遍历nums
  // 如果选择了2 相当于2 即 1
  // 如果选择了2 3 相当于 2 3 [2, 3] 2 + 1
  // 如果选择了2 3 5 相当于 2 3 5 [2, 3] [2, 5] [3, 5] [2, 3, 5] 3 + 3 + 1
  // 如果选择了2 3 3 5 相当于2 3 5 [2, 3] [2, 5] [3, 5] [2, 3, 5]  即 3 + 3 + 1 + 4（包含3的个数）
  // 如果选择了2 3 5 7 相当于2 3 5 7 [2, 3] [2, 5] [3, 5] [2, 7] [3, 7] [5, 7] [2, 3, 7] [2, 5, 7] [3, 5, 7] [2, 3, 5, 6, 7] 7 * 2 + 1
  // 如果选择了2 3 5 6 7 相当于2 3 5 6 7 [2, 3] [2, 5] [3, 5] [2, 7] [3, 7] [5, 7] [5, 6, 7] [2, 3, 7] [2, 5, 7] [3, 5, 7] 7 * 2 + 1 + 3 + 1

  // 规律，如果是加入了具有和现存的质因数不同的约数的数，相当于原始个数乘以2加1
  // 如果加入具有和现存的质因数相同的约数的数
  // 如果该数就是质数，需要找出具有不同约数的数的个数n（不包含相同数），然后加上2 * n
  // 如果该数不是质数，就需要找出具有不同约数的数的个数n（包含相同数），然后加上2 * n
  let ans = 0;
  const hash = new Map([
    [2, [2]],
    [3, [3]],
    [5, [5]],
    [6, [2, 3]],
    [7, [7]],
    [10, [2, 5]],
    [11, [11]],
    [13, [13]],
    [14, [2, 7]],
    [15, [3, 5]],
    [17, [17]],
    [19, [19]],
    [21, [3, 7]],
    [22, [2, 11]],
    [23, [23]],
    [26, [2, 13]],
    [29, [29]],
    [30, [2, 3, 5]],
  ]);
  // 声明保存数的质因数的set
  const factors = new Set();
  // 声明保存所有数的个数
  const all = new Map();
  // 声明1的个数
  let num1 = 0;
  // 遍历数组
  for (const num of nums) {
    if (hash.has(num)) {
      // 是否是可进入选择的数
      const factor = hash.get(num);
      // 判断是否是不同的数
      let isDiff = true;
      for (const f of factor) {
        if (factors.has(f)) {
          // 有就说明不是不同的数
          isDiff = false;
        }
        // 质因数加入
        factors.add(f);
      }
      if (isDiff) {
        // 如果是不同的数，直接乘以2加一即可
        ans = (ans * 2 + 1) % mod;
      } else {
        // 判断是否是质数
        if (factor.length > 1) {
          // 不是质数，需要找出不包含相同数的不同约数个数
          let total = 0;
          for (const [key, value] of all) {
            let isFactor = false;
            for (const f of factor) {
              if (key % f == 0) {
                // f是key的质因数
                isFactor = true;
                break;
              }
            }
            if (!isFactor) {
              total++;
            }
          }
          // ans += 2 ^ n
          ans = (ans + Math.pow(2, total)) % mod;
        } else {
          // 是质数，需要找出包含相同数的不同约数个数
          let total = 0;
          for (const [key, value] of all) {
            if (key % factor[0] !== 0) {
              total += value;
            }
          }
          ans += total 
        }
      }
    }
  }
};

// 分析，对于加入相同（即数的质约数在已存在选择数组中包含了），我们能求出现有数组中与该新加入数具有不同约数的数
// 那么通过它们应该就能得出新加入的数

// [2, 5,21,14,14,5, 15,15,7,7,15,15,7,3, 21,3]
// 2 5 14 14 5 7 7 7  => 通过这8个数能知道新加入的3可以多加30个数
// 2 5 =>  3 
// 2 5 5 => 3 + 2 => 5
// 2 5 5 7 => 5 + 5 + 1 => 11
// 2 5 5 7 7 => 11 + 5 + 1 => 17
// 2 5 5 7 7 7 => 17 + 5 + 1 = 23
// 2 5 5 7 7 7 14 => 23 + 3 + 1 = 27
// 
